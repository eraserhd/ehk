;;;; normalize.scm - perform some sort of "normalization" for source code


;; * produced forms: <var> quote set! define if lambda letrec let begin

(define (normalize form . src)
  (let ((defined '())
	(src (optional src #f)))
    (define (match-llist? llist args)
      (let loop ((ll llist) (args args))
	(cond ((null? ll) (null? args))
	      ((symbol? ll))
	      ((null? args) #f)
	      (else (loop (cdr ll) (cdr args))))))
    (define (walk-body body)
      (match body
	((('begin x)) (walk-body (cdr body)))
	((('begin xs ...) . more)
	 (walk-body (append xs more)))
	((x) (list (walk x)))
	((x . more)
	 (cons (walk x) (walk-body more)))))
    (define (walk x)
      (match x
	((or (? string?) (? number?) (? char?) (? boolean?)) x)
	((? symbol?) x)
	(((or 'set! 'define) v y)
	 (when (eq? 'define (car x))
	   (set! defined (cons (cons v src) defined)))
	 `(,(car x) ,v ,(walk y)))
	(('quote c) 
	 (if (or (string? c) (number? c) (char? c) (boolean? c))
	     c
	     x))
	(('if x y) 
	 `(if ,(walk x) ,(walk y)))
	(('if x y z)
	 `(if ,(walk x)
	      ,(walk y)
	      ,(walk z)))
	((('lambda () body ...))
	 (walk `(begin ,@body)))
	((('lambda llist body ...) args ...)
	 (match-let (((vars req rest) (parse-llist llist)))
	   (let loop ((vars req) (args args) (bs '()))
	     (cond ((null? vars)
		    (let ((bs (reverse bs)))
		      (cond (rest
			     `(let ,(append bs `((,rest (list ,(map walk args)))))
				,@(walk-body body)))
			    ((null? args)
			     `(let ,bs ,@(walk-body body)))
			    (else
			     (error 
			      "too many arguments to manifest lambda call" x)))))
		   ((null? args)
		    (error "too few arguments to manifest lambda call" x))
		   (else
		    (loop (cdr vars) (cdr args) 
			  (cons (list (car vars) (walk (car args))) bs)))))))
	(((or 'letrec 'let) () body ...)
	 (walk `(begin ,@body)))
	(((or 'letrec 'let) (bs ...) body ...)
	 `(,(car x) ,(map (lambda (b) (list (car b) (walk (cadr b)))) bs)
	    ,@(walk-body body)))
	((('letrec ((loop ('lambda (vars ...) body ...))) var) args ...)
	 (if (and (eq? loop var)
		  (symbol? loop)
		  (list? vars) (list? args)
		  (= (length vars) (length args)))
	     `(let ,loop ,(map list vars args) ,@(walk-body body))
	     (map walk x)))
	(('begin) '(void))
	(('begin . more)
	 `(begin ,@(walk-body more)))
	(('lambda llist body ...)
	 `(lambda ,llist ,@(walk-body body)))
	((op args ...)
	 (map walk x))
	(_ (error "bad expression" x))))
    (let ((form (walk form)))
      (list form defined))))

(define (parse-llist llist)
  (let loop ((ll llist) (vars '()))
    (cond ((null? ll)
	   (let ((vars (reverse vars)))
	     (list vars vars #f)))
	  ((symbol? ll) 
	   (let ((vars (reverse vars)))
	     (list (append vars (list ll)) vars ll)))
	  ((or (not (pair? ll)) (not (symbol? (car ll))))
	   (error "invalid lambda-list" llist))
	  (else (loop (cdr ll) (cons (car ll) vars))))))
